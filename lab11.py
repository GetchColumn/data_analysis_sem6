import numpy as np
import matplotlib.pyplot as plt  
from PIL import Image

# Если у вас нет библиотеки PIL, выполните команду:
#   pip install pillow


def main():
    with open('ex7data2.npy', 'rb') as f:
        X = np.load(f)
    K = 3

    ## 1. Присвоение кластеров
    initial_mu = np.array([[3, 3], [6, 2], [8, 5]])
    C = assign_clusters(X, initial_mu)
    print('\nБлижайшие центроиды к первым пяти примерам:', C[:5])
    print('Ожидаемое значение: [0 2 1 0 0]')
    input('Перейдите в терминал и нажмите Enter для продолжения...')

    # Удалите следующую строку для продолжения работы
    # return

    ## 2. Вычисление центроидов кластеров
    mu = compute_mean_centroids(X, C, K)
    print('\nЦентроиды:\n', mu)
    print('Ожидаемое значение (приблизительно):')
    print(' [[ 2.428301 3.157924 ]')
    print(' [ 5.813503 2.633656 ]')
    print(' [ 7.119387 3.616684 ]]')
    input('Перейдите в терминал и нажмите Enter для продолжения...')

    # Удалите следующую строку для продолжения работы
    # return

    ## 3. Начальная инициализация центроидов
    initial_mu = init_centroids(X, K)
    print('\nНачальная инициализация центродов:\n', initial_mu)
    Xf = np.round(X, 2)
    muf = np.round(initial_mu, 2)
    print('Инициализация верная') if np.sum((Xf[:, None] == muf).all(-1).any(1)) == K else print('Ошибка инициализации')
    input('Перейдите в терминал и нажмите Enter для продолжения...')

    # Удалите следующую строку для продолжения работы
    # return

    ## 4. Алгоритм K-средних
    C, mu = kmeans(X, initial_mu)
    print('\nНайденные алгоритмом K-средних центроиды:\n', mu)
    input('Перейдите в терминал и нажмите Enter для продолжения...')

    # Удалите следующую строку для продолжения работы
    # return

    ## 5. Отображение результата кластеризации
    draw_clusters(X, C, mu)
    input('Перейдите в терминал и нажмите Enter для продолжения...')

    # Удалите следующую строку для продолжения работы
    # return

    ## 6. Функция ошибки K-средних
    test_C = np.array([0, 0, 1, 1, 2])
    test_mu = np.array([[2.0, 5.0], [3.0, 1.0], [6.0, 3.0]])
    J = distortion_function(X[:5], test_C, test_mu)
    print('\nВычисленное значение функции ошибки от тестовых данных:', J)
    print('Ожидаемое значение (приблизительно): 10.915')
    input('Перейдите в терминал и нажмите Enter для продолжения...')

    # Удалите следующую строку для продолжения работы
    # return

    ## 7. Оптимальная кластеризация
    C, mu = iterative_kmeans(X, K, 10)
    print('\nНайденные итеративным алгоритмом K-средних центроиды:\n', mu)
    print('Ожидаемое значение (приблизительно, порядок может быть изменен):')
    print('[[1.954  5.026]')
    print(' [6.034  3.001]')
    print(' [3.044  1.015]]')
    draw_clusters(X, C, mu)
    input('Перейдите в терминал и нажмите Enter для продолжения...')

    # Удалите следующую строку для продолжения работы
    # return

    ## 8. Использование K-средних для сжатия изображений
    source_image = np.array(Image.open('bird_small.png'))   # Загрузить изображение и представить массивом
    K = 16  # Уменьшим число цветов изображения до 16 (если программа работает долго, возьмите K=2 или K=3)
    Q = 10  # Количество итераций для поиска лучшей кластеризации (если программа работает долго, возьмите Q=1 или Q=2)
    X = source_image.reshape(-1, 3)  # Преобразуем изображение в одномерный массив точек для использовать в алгоритме K-средних
    C, mu = iterative_kmeans(X, K, Q)  # Выполним кластеризацию изображения
    compressed_X = generate_centroids_array(C, mu)  # Сконструируем массив из центроидов кластеров вместо точек
    compressed_image = compressed_X.reshape(source_image.shape).astype(np.uint8)  # Преобразуем массив в двумерное изображение
    draw_images([source_image, compressed_image], ['Исходное', 'Сжатое'])  # Отобразим оба изображения
    Image.fromarray(compressed_image).save('bird_compressed.png')  # Сохраним сжатое изображение

    ## Конец работы


# Присвоение кластеров
def assign_clusters(X, mu):
    [m, n] = X.shape  # m - количество точек, n - количество признаков
    K = mu.shape[0]  # K - количество кластеров (количество центроидов)
    C = np.zeros(m, dtype=int)  # Вектор для хранения индексов кластеров для каждой точки

    # ------ добавьте свой код --------
    # Проходим по каждой точке выборки
    for i in range(m):
        # Текущая точка данных
        current_point = X[i, :]

        # Инициализируем минимальное расстояние очень большим числом
        min_distance_sq = float('inf')
        # Инициализируем индекс кластера для текущей точки
        assigned_cluster_idx = -1

        # Проходим по каждому центроиду
        for j in range(K):
            # Текущий центроид
            current_centroid = mu[j, :]

            # Вычисляем квадрат евклидова расстояния между точкой и центроидом
            # Квадрат расстояния используется для избежания операции извлечения корня,
            # что ускоряет вычисления, при этом порядок расстояний сохраняется.
            distance_sq = np.sum((current_point - current_centroid) ** 2)

            # Если найденное расстояние меньше текущего минимального, обновляем его
            if distance_sq < min_distance_sq:
                min_distance_sq = distance_sq
                assigned_cluster_idx = j

        # Присваиваем точке индекс ближайшего кластера
        C[i] = assigned_cluster_idx
    # ---------------------------------
    return C


# Вычисление центроидов кластеров
def compute_mean_centroids(X, C, K):
    [m, n] = X.shape  # m - количество точек, n - количество признаков
    mu = np.zeros((K, n)) # Матрица для хранения новых центроидов

    # ------ добавьте свой код --------
    # Проходим по каждому кластеру (от 0 до K-1)
    for k in range(K):
        # Выбираем все точки, которые были отнесены к текущему кластеру 'k'
        # Используем булеву индексацию: X[C == k] вернет все строки X,
        # для которых соответствующее значение в C равно k.
        points_in_cluster_k = X[C == k]

        # Проверяем, есть ли точки в этом кластере.
        # Если кластер пуст, его центроид остается на месте (или может быть переинициализирован,
        # но для данной задачи мы просто не будем его обновлять, оставляя 0, если он был инициализирован нулями).
        if len(points_in_cluster_k) > 0:
            # Вычисляем среднее значение для всех точек в этом кластере
            # np.mean(..., axis=0) вычисляет среднее по столбцам,
            # что дает среднее значение для каждого признака.
            mu[k, :] = np.mean(points_in_cluster_k, axis=0)
        # else:
            # Если кластер пуст, mu[k, :] останется нулями, как было инициализировано.
            # В более сложных реализациях здесь можно было бы сохранить старый центроид
            # или случайным образом переинициализировать его.
    # ---------------------------------
    return mu


# Начальная инициализация mu
def init_centroids(X, K):
    [m, n] = X.shape  # m - количество точек, n - количество признаков
    init_mu = np.zeros((K, n)) # Матрица для хранения начальных центроидов

    # ------ добавьте свой код --------
    # 1. Генерируем K случайных индексов из диапазона [0, m-1].
    #    np.random.choice позволяет выбрать K элементов из диапазона.
    #    replace=False гарантирует, что мы выберем K УНИКАЛЬНЫХ точек,
    #    то есть одна и та же точка не будет выбрана в качестве двух разных центроидов.
    random_indices = np.random.choice(m, K, replace=False)

    # 2. Используем эти случайные индексы для выбора K строк (точек) из матрицы X.
    #    Каждая выбранная строка становится начальным центроидом.
    init_mu = X[random_indices, :]
    # ---------------------------------
    return init_mu


# Алгоритм K-средних
def kmeans(X, initial_mu):
    [m, n] = X.shape
    K = initial_mu.shape[0]
    mu = initial_mu
    C = np.zeros(m, dtype=int) # Вектор для хранения индексов кластеров каждой точки

    # ------ добавьте свой код --------
    # Для отслеживания изменений центроидов и остановки цикла
    # Инициализируем prev_mu чем-то отличным от mu, чтобы цикл запустился хотя бы раз.
    # Например, можно использовать np.inf или просто None и проверять.
    # Более надежный способ: просто сохранять предыдущее состояние mu.
    prev_mu = np.zeros_like(mu) # Создаем массив той же формы, заполненный нулями

    # Цикл продолжается до тех пор, пока центроиды не перестанут меняться
    while not np.array_equal(mu, prev_mu):
        # 1. Сохраняем текущие центроиды как "предыдущие" для следующей итерации
        prev_mu = np.copy(mu) # Важно использовать .copy(), чтобы не ссылаться на тот же объект

        # 2. Присваиваем кластеры: для каждой точки находим ближайший центроид
        #    (предполагается, что функция assign_clusters уже реализована)
        C = assign_clusters(X, mu)

        # 3. Вычисляем новые центроиды на основе текущих присвоений кластеров
        #    (предполагается, что функция compute_centroids уже реализована)
        mu = compute_mean_centroids(X, C, K)

    # ---------------------------------
    return C, mu


# Отображение кластеризации
def draw_clusters(X, C, mu):
    K = mu.shape[0]
    plt.figure(figsize=(10, 7)) # Установка размера фигуры для лучшей читаемости

    # ------ добавьте свой код --------

    # 1. Отображение точек выборки, каждый кластер своим цветом
    # Пройдемся по каждому кластеру
    for k in range(K):
        # Выбираем все точки, которые принадлежат текущему кластеру 'k'
        points_in_cluster = X[C == k]
        plt.scatter(points_in_cluster[:, 0], points_in_cluster[:, 1],
                    label=f'Кластер {k+1}', # +1 для нумерации кластеров с 1
                    alpha=0.7) # Добавляем прозрачность для лучшего отображения перекрывающихся точек

    # 2. Отображение центроидов кластеров
    plt.scatter(mu[:, 0], mu[:, 1],
                marker='X', # Используем 'X' в качестве маркера для центроидов
                s=250,      # Увеличиваем размер маркера центроидов
                color='black', # Делаем центроиды черными для контраста
                label='Центроиды',
                edgecolors='white', # Белая обводка для лучшей видимости
                linewidths=1.5)

    # 3. Добавление заголовка и подписей осей
    plt.title('Результаты кластеризации K-средних')
    plt.xlabel('Признак 1')
    plt.ylabel('Признак 2')

    # 4. Добавление легенды
    plt.legend()

    # 5. Добавление сетки (опционально, но помогает)
    plt.grid(True)

    # ---------------------------------
    plt.show()


# Функция ошибки K-средних

def distortion_function(X, C, mu):
    J = 0
    # ------ добавьте свой код --------
    N = X.shape[0]  # количество точек
    total_dist = 0.0

    for i in range(N):
        centroid = mu[C[i]]            # центроид кластера для i-й точки
        diff = X[i] - centroid         # разница между точкой и центроидом
        dist_sq = np.dot(diff, diff)   # квадрат евклидова расстояния
        total_dist += dist_sq

    J = total_dist / N                # среднее значение по всем точкам
    # ---------------------------------
    return J


# Итеративный алгоритм K-средних
def iterative_kmeans(X, K, Q):
    [m, n] = X.shape
    optimum_C = np.zeros(m, dtype=int)
    optimum_mu = np.zeros((K, n))
    min_J = np.inf

    for q in range(Q):
        # 1. Случайная инициализация центроидов: выбираем K случайных точек из X
        indices = np.random.choice(m, K, replace=False)
        initial_mu = X[indices]

        # 2. Запуск алгоритма K-средних с данной инициализацией
        C, mu = kmeans(X, initial_mu)

        # 3. Вычисляем ошибку кластеризации
        J = distortion_function(X, C, mu)

        # 4. Сохраняем лучший результат
        if J < min_J:
            min_J = J
            optimum_C = C.copy()
            optimum_mu = mu.copy()
    return optimum_C, optimum_mu


# Генерация массива, состоящего из центроидом кластеров каждой точки выборки
def generate_centroids_array(C, mu):
    K = mu.shape[0]
    X = np.zeros((C.shape[0], mu.shape[1]))
    for k in range(K):
        X[C == k, :] = mu[k, :]
    return X


# Показ изображений
def draw_images(images, labels):
    N = len(images)
    fig, axs = plt.subplots(1, 2)
    for i in range(N):
        axs[i].imshow(images[i])
        axs[i].set_title(labels[i])
    fig.show()


if __name__ == '__main__':
    # plt.ion()
    main()
    input('Перейдите в терминал и нажмите Enter для завершения')
    plt.clf()
